# Implement Token Endpoint in Authorization Server (`/token`)

## Overview

After receiving the authorization code, the MCP client (ChatGPT) can request an access token, which can be used to authenticate requests to the MCP server. ChatGPT makes a `POST` request to the token endpoint (`/token` or as defined by `token_endpoint` in the [Authorization Server Metadata][Authorization Server Metadata]). The authorization server must:

1. Validate the request payload (client ID, grant type, authorization code, redirect URI, code verifier, resource, scopes, etc.).
2. Recompute the PKCE code challenge using the supplied `code_verifier` and compare it to the stored challenge associated with the authorization code.
3. Ensure the authorization code was issued to the same `client_id`, `redirect_uri`, `resource`, and `scope` values.
4. Issue new tokens (ID, access, refresh tokens) if validation succeeds.

**NOTE**: The appropriate claims should be added to the token. These will be validated by the protected resource (MCP server) during token validation. See **ID Token** and **Access Token** below.
**NOTE**: Both `authorization_code` and `refresh_token` grant types should be handled by the `/token` endpoint. These grant types are used to exchange an authorization code for an access token or reissue an access token when the client's current token has expired, respectively. For the `refresh_token` grant type, the client will provide its refresh token, which should be validated using the client's ID. The refresh token is completely opaque and is only used to reissue an access token.

**Access Token Request**
* **URL**: The access token endpoint is responsible for validating and verifying the access token request and issuing access tokens. The URL of the endpoint is published to the authorization server's Authorization Server Metadata using the `token_endpoint` field. 

**Parameters**
* `client_id`: Unique identifier for the client. The client ID is created during registration (DCR).
* `grant_type`: Specifies the method/flow used to obtain an access token. OAuth 2.1 supports these grant types: `authorization_code`, `client_credentials`, `refresh_token`. We will only handle  `authorization_code` and `refresh_token` grant types.
* `code`: Authorization code generated after the successful authorization flow.
* `redirect_uri`: URI that was associated with the authorization code. Used solely for verification; the token endpoint does **not** redirect.
* `code_verifier`: Code verifier generated by the client. Used to recompute the code challenge and verify the code challenge for the authorization code (PKCE).
* `resource`: Resource indicator (audience) the token must be minted for.
* `scope`: Space-separated scopes being requested during the exchange (must be a subset of the authorization code scopes).
* `refresh_token`: A valid refresh token that can be exchanged for a new access token when `grant_type=refresh_token`.

**Access Token Response**
Returns JSON with the following fields:
```json
{
  "access_token": "eyJ...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "<REFRESH_TOKEN>",
  "id_token": "eyJ...",
  "scope": "openid profile email"
}
```

* `access_token` [REQUIRED]: The token to use for API calls
* `token_type` [REQUIRED]: Usually "Bearer" - tells you how to use the token
* `expires_in` [RECOMMENDED]: Seconds until the access token expires
* `refresh_token` [OPTIONAL]: Token to get new access tokens without re-authentication
* `scope` [OPTIONAL]: Space-separated list of granted scopes (may be less than requested)
* `id_token` [OIDC only]: JWT with user identity claims


**ID Token**
The ID token is an OIDC token that provides user information to the client (ChatGPT):

```json
{
  "iss": "https://auth.functionhealth.com",
  "sub": "123",
  "aud": "abc123xyz789",
  "exp": 1234567890,
  "iat": 1234567890,
  "nonce": "xyz",
  "email": "user@functionhealth.com"
}
```

**Required**
* `iss` (issuer): URL of the authorization server.
* `sub` (subject): Unique identifier for the user.
* `aud` (audience): Client ID that this token is intended for.
* `exp` (expiration): Unix timestamp when token expires.
* `iat` (issued at): Unix timestamp when token was issued.

**Conditionally Required**
* `auth_time`: Required if `max_age` was in auth request or if `auth_time` was requested.
* `nonce`: Required if `nonce` was sent in the authorization request.

**Optional**
* `scope`: Scopes that were granted (should match response `scope`).

**Access Token**
The access token used to make authenticated requests to the MCP server.

```json
{
  "iss": "https://auth.functionhealth.com",
  "sub": "248289761001",
  "aud": "https://api.functionhealth.com",
  "exp": 1234567890,
  "iat": 1234567890,
  "client_id": "chatgpt-client-id",
  "jti": "abc123def456",
  "scope": "openid profile email read:data"
}
```

**Required**
* `iss` (issuer): URL of the authorization server.
* `sub` (subject): Unique identifier for the user.
* `aud` (audience): Identifier for the resource server (MCP server).
* `exp` (expiration): Unix timestamp when token expires.
* `iat` (issued at): Unix timestamp when token was issued.
* `client_id`: Client ID that this token is intended for.
* `jti`: Unique identifier for the token (prevents replay).

**Optional**
* `scope`: Scopes that were granted (should match response `scope`).
* `auth_time`: When user authentication occurred.

**NOTE**
* Include `aud` equal to the resource indicator (MCP server), so the resource can verify the token was minted for it.
* Include all required claims ([RFC 7519][RFC 7519]).
* Sign the token with the authorization server's private key (matching the JWKS exposed at `jwks_uri`). Set the `kid` (key ID) header, so clients can select the correct public key during verification.

**NOTE**: Use the `jwt.encode()` method of the [PyJWT][PyJWT] library to generate the ID and access tokens.

**Error Codes**:
* `invalid_request`: Malformed request
* `invalid_client`: Client authentication failed
* `invalid_grant`: Auth code invalid/expired/mismatched
* `unauthorized_client`: Client not authorized for this grant type
* `unsupported_grant_type`: Grant type not supported

See [RFC 6749 Section 5.2][RFC 6749 Section 5.2] for a full list of error response parameters.

## Acceptance Criteria
* A token (`/token`) endpoint exists in the authorization server that is responsible for issuing access tokens.
* The endpoint validates the client ID, redirect URI, resource indicator, scopes, and grant type.
* The authorization code (`code`) is validated and marked as consumed.
* The PKCE code challenge is validated using the code verifier (`code_verifier`).
* Both the access token and ID token are generated:
    * **Access Token**: Used to access the protected resource (MCP server).
    * **ID Token**: Used by the client to learn identity claims about the authenticated user.
* For `grant_type=refresh_token`, the endpoint validates the refresh token (client binding, expiry, rotation) before issuing new tokens.
* A short-lived refresh token is generated and stored (e.g., Redis/PostgreSQL). **NOTE**: Rotate the refresh token on each use and bind it to `client_id`.
* The JSON response matches the Access Token Response schema above and includes the granted scopes.

[Authorization Server Metadata]: https://datatracker.ietf.org/doc/html/rfc8414#section-2
[RFC 7519]: https://datatracker.ietf.org/doc/html/rfc7519
[PyJWT]: https://pyjwt.readthedocs.io/en/stable
[RFC 6749 Section 5.2]: https://datatracker.ietf.org/doc/html/rfc6749#section-5.2
